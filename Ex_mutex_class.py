​​​​'''
Алексей хочет войти в комнату.
Алексей вошел в комнату.
Мария хочет войти в комнату.
Иван хочет войти в комнату.
Алексей вышел из комнаты.
Мария вошел в комнату.
Мария вышел из комнаты.
Иван вошел в комнату.
Иван вышел из комнаты.

Room() представляет собой комнату с замком. Метод use() символизирует процесс использования комнаты,
 который защищен asyncio.Lock(). Это гарантирует, что в любой момент времени комнатой может пользоваться только один "человек".
Функция person() представляет человека (или задачу), который хочет использовать комнату. 
Она вызывает room.use(), ожидая своей очереди, если комната занята.
В функции main() асинхронно запускаются задачи для нескольких "людей", которые хотят войти в комнату. 
Использование asyncio.gather() позволяет запустить их одновременно, демонстрируя конкуренцию за ресурс (комнату).
'''
import sys,time
import asyncio

# Эмуляция комнаты с замком
class Room:
    def __init__(self):
        self.lock = asyncio.Lock()

    async def use(self, name):
        # Захват мьютекса
        await self.lock.acquire()
        try:
            print(f"{name} вошел в комнату.")
            # Имитация выполнения работы внутри комнаты
            await asyncio.sleep(1)
            print(f"{name} вышел из комнаты.")
        finally:
            # Освобождение мьютекса
            self.lock.release()

async def person(name, room):
    # Человек (задача) пытается использовать комнату
    print(f"{name} хочет войти в комнату.")
    await room.use(name)

async def main():
    room = Room()  # Инициализация комнаты с замком

    # Создание задач для нескольких людей, пытающихся войти в комнату
    await asyncio.gather(
        person("Алексей", room),
        person("Мария", room),
        person("Иван", room)
    )



start_time = time.perf_counter()
asyncio.run(main())
stop_time =  time.perf_counter()
Inetrval = stop_time - start_time
print(f'\nОбщее время выполнения {Inetrval:.7f}')
if not (len(sys.argv) > 1 and sys.argv[1] == 'cons'):input(':-> ')
sys.exit(0)
